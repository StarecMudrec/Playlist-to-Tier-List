<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playlist Tier List Maker</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        .tier-label {
            min-width: 10px;
            width: auto;
            cursor: pointer;
            box-sizing: content-box;
            transition: width 0.2s ease;
            white-space: nowrap;
            position: relative;
        }
        
        .tier-content {
            min-width: 0;
            flex-grow: 1;
        }
        
        .tier-row {
            display: flex;
            margin-bottom: 5px;
            min-height: 60px;
        }
    </style>
</head>
<body>
    <div class="container-fluid dark-theme app-shell">
        <div class="page-header mb-3">
            <h1 class="mb-1">Playlist Tier List Maker</h1>
            <div class="text-muted small">Paste a Yandex Music playlist link or an iframe snippet, then drag tracks into tiers.</div>
        </div>

        <form method="post" class="playlist-form">
            <div class="form-group">
                <label for="playlist_url">Playlist URL:</label>
                <input type="text" class="form-control" id="playlist_url" name="playlist_url" value="{{ playlist_url if playlist_url else '' }}" placeholder="https://music.yandex.ru/users/.../playlists/... or iframe snippet" required>
            </div>
            <div class="d-flex flex-wrap align-items-center gap-2">
                <button type="submit" class="btn btn-primary">Load Playlist</button>
                <button id="download-btn" type="button" class="btn btn-outline-light">Download Tier List</button>
                <button id="clear-storage-btn" type="button" class="btn btn-outline-light">Clear Saved Data</button>
            </div>
        </form>

        <div class="d-flex align-items-center gap-2 mt-4 mb-2">
            <button id="add-tier-btn" type="button" class="btn btn-outline-light">+ Add tier</button>
        </div>
        <div id="tier-list-capture" class="tier-list-container mt-2">
            <div class="tier-row" data-tier-id="S">
                <div class="tier-label tier-s tier-label-with-controls">
                    <input type="text" value="S" class="tier-name">
                    <input type="color" class="tier-color" value="#FFD700" title="Tier color">
                    <button type="button" class="tier-delete" title="Delete tier">×</button>
                </div>
                <div class="tier-content" data-tier="S"></div>
            </div>
            <div class="tier-row" data-tier-id="A">
                <div class="tier-label tier-a tier-label-with-controls">
                    <input type="text" value="A" class="tier-name">
                    <input type="color" class="tier-color" value="#00FF7F" title="Tier color">
                    <button type="button" class="tier-delete" title="Delete tier">×</button>
                </div>
                <div class="tier-content" data-tier="A"></div>
            </div>
            <div class="tier-row" data-tier-id="B">
                <div class="tier-label tier-b tier-label-with-controls">
                    <input type="text" value="B" class="tier-name">
                    <input type="color" class="tier-color" value="#00BFFF" title="Tier color">
                    <button type="button" class="tier-delete" title="Delete tier">×</button>
                </div>
                <div class="tier-content" data-tier="B"></div>
            </div>
            <div class="tier-row" data-tier-id="C">
                <div class="tier-label tier-c tier-label-with-controls">
                    <input type="text" value="C" class="tier-name">
                    <input type="color" class="tier-color" value="#ADFF2F" title="Tier color">
                    <button type="button" class="tier-delete" title="Delete tier">×</button>
                </div>
                <div class="tier-content" data-tier="C"></div>
            </div>
            <div class="tier-row" data-tier-id="D">
                <div class="tier-label tier-d tier-label-with-controls">
                    <input type="text" value="D" class="tier-name">
                    <input type="color" class="tier-color" value="#FFA500" title="Tier color">
                    <button type="button" class="tier-delete" title="Delete tier">×</button>
                </div>
                <div class="tier-content" data-tier="D"></div>
            </div>
            <div class="tier-row" data-tier-id="F">
                <div class="tier-label tier-f tier-label-with-controls">
                    <input type="text" value="F" class="tier-name">
                    <input type="color" class="tier-color" value="#FF4500" title="Tier color">
                    <button type="button" class="tier-delete" title="Delete tier">×</button>
                </div>
                <div class="tier-content" data-tier="F"></div>
            </div>
            <div class="tier-row tier-row-unsorted" data-tier-id="unsorted">
                <div class="tier-label unsorted-tier tier-label-with-controls">
                    <input type="text" value="N/A" class="tier-name">
                    <input type="color" class="tier-color" value="#9aa0a6" title="Tier color">
                    <!-- no delete for unsorted -->
                </div>
                <div class="tier-content" data-tier="unsorted">
                    {% if playlist_data %}
                        {% for track in playlist_data %}
                            <div class="track-item" id="track-{{ track.index }}" draggable="true" data-track-title="{{ track.title }}" data-artwork-url="{{ track.thumbnail }}">
                                <img src="{{ track.thumbnail }}" alt="{{ track.title }}" class="track-artwork" crossorigin="anonymous" draggable="false">
                                <p class="track-title">{{ track.title }}</p>
                            </div>
                        {% endfor %}
                    {% endif %}
                </div>
            </div>
        </div>
        {% if error_message %}
          <div class="alert alert-danger mt-3">{{ error_message|safe }}</div>
        {% endif %}
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        const downloadBtn = document.getElementById('download-btn');
        const clearStorageBtn = document.getElementById('clear-storage-btn');
        const tierListCapture = document.getElementById('tier-list-capture');
        const playlistUrlInput = document.getElementById('playlist_url');
    
        let draggedItem = null;
        
        function getTierContents() { return document.querySelectorAll('.tier-content'); }
        function getTrackItems() { return document.querySelectorAll('.track-item'); }
        function getTierNameInputs() { return document.querySelectorAll('.tier-name'); }
        
        function applyTierColor(tierRow, hexColor) {
            const label = tierRow.querySelector('.tier-label');
            if (label) label.style.backgroundColor = hexColor;
        }
        
        function createTierRow(tierId, name, color) {
            const row = document.createElement('div');
            row.className = 'tier-row';
            row.setAttribute('data-tier-id', tierId);
            const hex = (color || '#9aa0a6').replace(/^#?/, '#');
            row.innerHTML =
                '<div class="tier-label tier-label-with-controls" style="background-color:' + hex + '">' +
                '<input type="text" value="' + (name || 'New').replace(/"/g, '&quot;') + '" class="tier-name">' +
                '<input type="color" class="tier-color" value="' + hex + '" title="Tier color">' +
                '<button type="button" class="tier-delete" title="Delete tier">×</button>' +
                '</div>' +
                '<div class="tier-content" data-tier="' + tierId + '"></div>';
            bindTierRowEvents(row);
            return row;
        }
        
        function bindTierRowEvents(row) {
            const nameInput = row.querySelector('.tier-name');
            const tierContent = row.querySelector('.tier-content');
            if (nameInput) {
                updateTierLabelWidth(nameInput);
                nameInput.addEventListener('input', function() { updateTierLabelWidth(this); savePlacements(); });
                nameInput.addEventListener('mousedown', function(e) { e.stopPropagation(); });
                nameInput.addEventListener('blur', function() {
                    if (this.value.trim() === '') { this.value = this.defaultValue || 'New'; updateTierLabelWidth(this); }
                    savePlacements();
                });
            }
            if (tierContent) {
                tierContent.addEventListener('dragover', (e) => { e.preventDefault(); });
                tierContent.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const trackId = e.dataTransfer.getData('text/plain');
                    const trackItem = document.getElementById(trackId);
                    if (trackItem) { tierContent.appendChild(trackItem); savePlacements(); }
                });
            }
        }
        
        function deleteTier(tierRow) {
            const tierContent = tierRow.querySelector('.tier-content');
            const tierId = tierContent.getAttribute('data-tier');
            if (tierId === 'unsorted') return;
            const unsortedContent = document.querySelector('.tier-content[data-tier="unsorted"]');
            if (!unsortedContent) return;
            const tracks = tierContent.querySelectorAll('.track-item');
            tracks.forEach(t => unsortedContent.appendChild(t));
            tierRow.remove();
            savePlacements();
        }
        
        // Generate a storage key based on playlist URL
        function getStorageKey() {
            const urlInput = document.getElementById('playlist_url');
            const url = urlInput ? urlInput.value.trim() : '';
            if (!url) {
                // Fallback: use track IDs to create a unique key
                const allTracks = document.querySelectorAll('.track-item');
                const trackIds = Array.from(allTracks).map(item => item.id).sort().join(',');
                return `tier_list_${trackIds.substring(0, 50)}`;
            }
            return `tier_list_${url}`;
        }
        
        // Save track placements to localStorage
        function savePlacements() {
            const allTracks = document.querySelectorAll('.track-item');
            if (allTracks.length === 0) return;
            
            const placements = {};
            document.querySelectorAll('.tier-content').forEach(tierContent => {
                const tier = tierContent.getAttribute('data-tier');
                const tracks = tierContent.querySelectorAll('.track-item');
                tracks.forEach(track => {
                    placements[track.id] = tier;
                });
            });
            
            // Save tier names and colors and order
            const tierNames = {};
            const tierColors = {};
            const tierOrder = [];
            document.querySelectorAll('.tier-row').forEach(row => {
                const tierContent = row.querySelector('.tier-content');
                const tier = tierContent.getAttribute('data-tier');
                tierOrder.push(tier);
                const nameInput = row.querySelector('.tier-name');
                const colorInput = row.querySelector('.tier-color');
                if (nameInput) tierNames[tier] = nameInput.value;
                if (colorInput) tierColors[tier] = colorInput.value;
            });
            
            const storageKey = getStorageKey();
            localStorage.setItem(storageKey, JSON.stringify({
                placements: placements,
                tierNames: tierNames,
                tierColors: tierColors,
                tierOrder: tierOrder
            }));
        }
        
        // Load track placements from localStorage
        function loadPlacements() {
            const allTracks = document.querySelectorAll('.track-item');
            if (allTracks.length === 0) return;
            
            const storageKey = getStorageKey();
            const saved = localStorage.getItem(storageKey);
            
            if (!saved) return;
            
            try {
                const data = JSON.parse(saved);
                
                // Restore custom tiers in correct order (create missing rows and insert at right position)
                if (data.tierOrder && Array.isArray(data.tierOrder)) {
                    const container = document.getElementById('tier-list-capture');
                    const unsortedRow = container.querySelector('.tier-row-unsorted');
                    for (let i = 0; i < data.tierOrder.length; i++) {
                        const tierId = data.tierOrder[i];
                        if (tierId === 'unsorted') continue;
                        if (container.querySelector('.tier-row[data-tier-id="' + tierId + '"]')) continue;
                        const nextId = data.tierOrder[i + 1];
                        const nextRow = nextId ? container.querySelector('.tier-row[data-tier-id="' + nextId + '"]') : unsortedRow;
                        const row = createTierRow(tierId, data.tierNames[tierId] || 'New', data.tierColors[tierId] || '#9aa0a6');
                        container.insertBefore(row, nextRow || unsortedRow);
                    }
                }
                
                // Restore tier names
                if (data.tierNames) {
                    document.querySelectorAll('.tier-name').forEach(input => {
                        const tierRow = input.closest('.tier-row');
                        const tierContent = tierRow.querySelector('.tier-content');
                        const tier = tierContent.getAttribute('data-tier');
                        if (data.tierNames[tier]) {
                            input.value = data.tierNames[tier];
                            updateTierLabelWidth(input);
                        }
                    });
                }
                
                // Restore tier colors
                if (data.tierColors) {
                    document.querySelectorAll('.tier-color').forEach(input => {
                        const tierRow = input.closest('.tier-row');
                        const tierContent = tierRow.querySelector('.tier-content');
                        const tier = tierContent.getAttribute('data-tier');
                        if (data.tierColors[tier]) {
                            input.value = data.tierColors[tier];
                            applyTierColor(tierRow, data.tierColors[tier]);
                        }
                    });
                }
                
                // Restore track placements
                if (data.placements) {
                    Object.keys(data.placements).forEach(trackId => {
                        const trackItem = document.getElementById(trackId);
                        const targetTier = data.placements[trackId];
                        if (trackItem && targetTier) {
                            const targetTierContent = document.querySelector(`.tier-content[data-tier="${targetTier}"]`);
                            if (targetTierContent) {
                                targetTierContent.appendChild(trackItem);
                            }
                        }
                    });
                }
            } catch (e) {
                console.error('Error loading placements:', e);
            }
        }
    
        // Event delegation for tier color and delete (works for initial + dynamically added tiers)
        tierListCapture.addEventListener('input', function(e) {
            if (e.target.classList.contains('tier-color')) {
                const row = e.target.closest('.tier-row');
                if (row) { applyTierColor(row, e.target.value); savePlacements(); }
            }
        });
        tierListCapture.addEventListener('click', function(e) {
            if (e.target.classList.contains('tier-delete')) {
                const row = e.target.closest('.tier-row');
                if (row) deleteTier(row);
            }
        });
        
        // Add tier button
        document.getElementById('add-tier-btn').addEventListener('click', function() {
            const container = document.getElementById('tier-list-capture');
            const unsortedRow = container.querySelector('.tier-row-unsorted');
            const tierId = 'custom-' + Date.now();
            const row = createTierRow(tierId, 'New', '#9aa0a6');
            container.insertBefore(row, unsortedRow);
            savePlacements();
        });
        
        // Initialize tier labels (initial rows only; new rows get bound in bindTierRowEvents)
        getTierNameInputs().forEach(input => {
            updateTierLabelWidth(input);
            input.addEventListener('input', function() { updateTierLabelWidth(this); savePlacements(); });
            input.addEventListener('mousedown', function(e) { e.stopPropagation(); });
            input.addEventListener('blur', function() {
                if (this.value.trim() === '') { this.value = this.defaultValue || 'New'; updateTierLabelWidth(this); }
                savePlacements();
            });
        });
        
        function updateTierLabelWidth(input) {
            const tempSpan = document.createElement('span');
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.whiteSpace = 'nowrap';
            tempSpan.style.font = window.getComputedStyle(input).font;
            tempSpan.textContent = input.value || input.placeholder;
            
            document.body.appendChild(tempSpan);
            const textWidth = tempSpan.getBoundingClientRect().width;
            document.body.removeChild(tempSpan);
            
            // Total width: text + padding + color picker (+ delete + gaps if present)
            const hasDelete = input.closest('.tier-row').querySelector('.tier-delete');
            const controlsWidth = 24 + 6 + (hasDelete ? 26 + 6 : 0);
            const totalWidth = textWidth + 30 + controlsWidth;
            
            input.parentElement.style.width = `${totalWidth}px`;
            input.style.width = `${textWidth}px`;
        }

        getTrackItems().forEach(trackItem => {
            trackItem.addEventListener('dragstart', (event) => {
                const item = event.currentTarget;
                draggedItem = item;
                event.dataTransfer.setData('text/plain', item.id);
            });
            trackItem.addEventListener('dragend', () => { draggedItem = null; });
        });
    
        const scrollSpeed = 10;
    
        document.addEventListener('dragover', (event) => {
            if(!draggedItem){
                return;
            }
            const scrollThreshold = 100;
            const scrollUpThreshold = 100;
            const scrollDownThreshold = window.innerHeight - scrollThreshold;
    
            if (event.clientY < scrollUpThreshold) {
                window.scrollBy(0, -scrollSpeed);
            } else if (event.clientY > scrollDownThreshold){
                window.scrollBy(0, scrollSpeed);
            }
        });
    
        getTierContents().forEach(dropZone => {
            dropZone.addEventListener('dragover', (event) => { event.preventDefault(); });
            dropZone.addEventListener('drop', (event) => {
                event.preventDefault();
                const trackId = event.dataTransfer.getData('text/plain');
                const trackItem = document.getElementById(trackId);
                if (trackItem) { dropZone.appendChild(trackItem); savePlacements(); }
            });
        });
    
        downloadBtn.addEventListener('click', () => {
            getTierNameInputs().forEach(input => {
                input.disabled = true;
                input.style.pointerEvents = 'none';
            });
            
            // Calculate optimal columns for ~4:3 ratio with fixed card size 140x180
            const allTracks = Array.from(document.querySelectorAll('.track-item'));
            const totalTracks = allTracks.length;
            if (totalTracks === 0) {
                alert('No tracks to export');
                return;
            }
            
            // Fixed card dimensions in export (140px width, ~180px height including padding/gap)
            const cardWidth = 140;
            const cardGap = 6;
            const cardHeight = 180; // card height (120px artwork + padding + title)
            const tierLabelHeight = 48;
            const tierRowGap = 6;
            const tierPadding = 8 * 2; // left + right padding
            const numTiers = document.querySelectorAll('.tier-row').length;
            
            // Count tracks per tier
            const tracksPerTier = {};
            document.querySelectorAll('.tier-row').forEach(row => {
                const tierContent = row.querySelector('.tier-content');
                const tier = tierContent.getAttribute('data-tier');
                tracksPerTier[tier] = tierContent.querySelectorAll('.track-item').length;
            });
            
            // Try different column counts and export widths
            let bestCols = 8;
            let bestWidth = 1600;
            let bestRatio = Infinity;
            const targetRatio = 4/3;
            const minCols = 4;
            const maxCols = 20; // reasonable max for readability
            
            for (let cols = minCols; cols <= maxCols; cols++) {
                const exportWidth = cols * (cardWidth + cardGap) + tierPadding;
                let maxRows = 0;
                // Find max rows needed across all tiers
                Object.values(tracksPerTier).forEach(count => {
                    const rows = Math.ceil(count / cols);
                    if (rows > maxRows) maxRows = rows;
                });
                
                const estimatedHeight = numTiers * (tierLabelHeight + maxRows * cardHeight + tierRowGap);
                const ratio = exportWidth / estimatedHeight;
                const diff = Math.abs(ratio - targetRatio);
                
                // Prefer ratios >= 4/3 (wider rather than taller)
                if (ratio >= targetRatio && diff < bestRatio) {
                    bestRatio = diff;
                    bestCols = cols;
                    bestWidth = exportWidth;
                } else if (ratio < targetRatio && bestRatio === Infinity) {
                    // If no good "wide enough" option, take the best available
                    if (diff < bestRatio) {
                        bestRatio = diff;
                        bestCols = cols;
                        bestWidth = exportWidth;
                    }
                }
            }
            
            html2canvas(tierListCapture, {
                backgroundColor: '#0b1020',
                useCORS: true,
                allowTaint: false,
                imageTimeout: 15000,
                scale: 1.5,
                scrollX: 0,
                scrollY: -window.scrollY,
                windowWidth: bestWidth,
                windowHeight: 10000, // Large enough, will be cropped
                onclone: (doc) => {
                    doc.body.style.background = '#0b1020';
                    doc.body.style.color = '#f0f0f0';
                    const captureEl = doc.getElementById('tier-list-capture');
                    if (captureEl) {
                        captureEl.style.background = '#0b1020';
                        captureEl.style.width = bestWidth + 'px';
                        captureEl.style.maxWidth = 'none';
                        captureEl.style.minWidth = bestWidth + 'px';
                        captureEl.classList.add('capture-export');
                        captureEl.style.setProperty('--capture-cols', bestCols);
                        captureEl.style.setProperty('--export-width', bestWidth + 'px');
                        // Ensure all tier contents use the grid
                        captureEl.querySelectorAll('.tier-content').forEach(tc => {
                            tc.style.background = 'rgba(0,0,0,0.18)';
                        });
                    }
                }
            }).then(canvas => {
                try {
                    const imgData = canvas.toDataURL('image/jpeg', 0.95);
                    const a = document.createElement('a');
                    a.href = imgData;
                    a.download = 'tier_list.jpg';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                } catch (e) {
                    alert(
                        "Export failed. Most likely some cover images are blocked by CORS.\n" +
                        "Try a playlist with fewer/other covers, or run through a proxy that adds CORS headers."
                    );
                    console.error(e);
                } finally {
                    getTierNameInputs().forEach(input => {
                        input.disabled = false;
                        input.style.pointerEvents = 'auto';
                    });
                }
            });
        });
        
        // Clear localStorage button handler
        clearStorageBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved tier list data? This action cannot be undone.')) {
                // Clear all tier_list_ keys from localStorage
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('tier_list_')) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));
                
                // Reset tier names to defaults
                const defaultTierNames = {
                    'S': 'S',
                    'A': 'A',
                    'B': 'B',
                    'C': 'C',
                    'D': 'D',
                    'F': 'F',
                    'unsorted': 'N/A'
                };
                
                getTierNameInputs().forEach(input => {
                    const tierRow = input.closest('.tier-row');
                    const tierContent = tierRow.querySelector('.tier-content');
                    const tier = tierContent.getAttribute('data-tier');
                    if (defaultTierNames[tier]) {
                        input.value = defaultTierNames[tier];
                        updateTierLabelWidth(input);
                    }
                });
                
                // Reload the page with GET so the server returns a clean state (no link, no tracks)
                window.location.href = window.location.pathname || '/';
            }
        });
        
        // Load placements when page loads (after a short delay to ensure DOM is ready)
        setTimeout(() => {
            loadPlacements();
        }, 100);
    </script>
</body>
</html>